// this file is ai generated by gemini 3 pro

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <time.h>
#include <errno.h>
#include <arpa/inet.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <sys/ioctl.h>

// --- Constants ---
#define PTP_PORT_EVENT    319
#define PTP_PORT_GENERAL  320
#define MCAST_ADDR        "224.0.1.129"
#define PTP_VERSION       2

// Message Types
#define MSG_SYNC          0x0
#define MSG_DELAY_REQ     0x1
#define MSG_FOLLOW_UP     0x8
#define MSG_DELAY_RESP    0x9
#define MSG_ANNOUNCE      0xB

// Lengths
#define HEADER_LEN        34
#define SYNC_LEN          44
#define FOLLOW_UP_LEN     44
#define DELAY_REQ_LEN     44
#define DELAY_RESP_LEN    54

// --- Structs ---
typedef struct __attribute__((packed)) {
    uint8_t  transportSpecific_msgType; // 0: transport, 0-3: type
    uint8_t  versionPTP;
    uint16_t messageLength;
    uint8_t  domainNumber;
    uint8_t  reserved1;
    uint16_t flagField;
    int64_t  correctionField;
    uint32_t reserved2;
    uint8_t  clockIdentity[8];
    uint16_t sourcePortId;
    uint16_t sequenceId;
    uint8_t  controlField;
    int8_t   logMessageInterval;
} PTPHeader;

typedef struct __attribute__((packed)) {
    PTPHeader header;
    uint16_t  originTimestamp[5]; // 48 bit sec + 32 bit ns (split for alignment)
} PTPSync;

typedef struct __attribute__((packed)) {
    PTPHeader header;
    uint16_t  preciseOriginTimestamp[5];
} PTPFollowUp;

typedef struct __attribute__((packed)) {
    PTPHeader header;
    uint16_t  originTimestamp[5];
} PTPDelayReq;

typedef struct __attribute__((packed)) {
    PTPHeader header;
    uint16_t  receiveTimestamp[5];
    uint8_t   requestingPortIdentity[10];
} PTPDelayResp;

// --- Globals ---
int sock_evt, sock_gen;
struct sockaddr_in mcast_addr_evt, mcast_addr_gen;
uint16_t sequence_id = 0;
uint8_t my_clock_id[8] = {0x11, 0x22, 0x33, 0xFF, 0xFE, 0x44, 0x55, 0x66};
char interface_ip[INET_ADDRSTRLEN];

// Slave State
struct {
    uint16_t last_sync_seq;
    struct timespec t1; // Master Sync Time
    struct timespec t2; // Slave Sync Ingress
    struct timespec t3; // Slave DelayReq Egress
    struct timespec t4; // Master DelayReq Ingress
    int64_t initial_offset_ns;
    int has_initial_offset;
} slave_state;

// --- Helpers ---

void get_time(struct timespec *ts) {
    clock_gettime(CLOCK_REALTIME, ts);
}

// Convert 48-bit sec + 32-bit ns PTP format to timespec
void ptp_to_timespec(uint16_t *ptp_ts, struct timespec *ts) {
    // PTP Timestamp format: 48 bits seconds, 32 bits nanoseconds
    // Stored as 5 uint16s in our packed struct
    uint64_t sec = 0;
    sec |= (uint64_t)ntohs(ptp_ts[0]) << 32;
    sec |= (uint64_t)ntohs(ptp_ts[1]) << 16;
    sec |= (uint64_t)ntohs(ptp_ts[2]);
    
    uint32_t ns = 0;
    ns |= (uint32_t)ntohs(ptp_ts[3]) << 16;
    ns |= (uint32_t)ntohs(ptp_ts[4]);
    
    ts->tv_sec = sec;
    ts->tv_nsec = ns;
}

// Convert timespec to PTP format
void timespec_to_ptp(struct timespec *ts, uint16_t *ptp_ts) {
    uint64_t sec = ts->tv_sec;
    uint32_t ns = ts->tv_nsec;
    
    ptp_ts[0] = htons((sec >> 32) & 0xFFFF);
    ptp_ts[1] = htons((sec >> 16) & 0xFFFF);
    ptp_ts[2] = htons(sec & 0xFFFF);
    ptp_ts[3] = htons((ns >> 16) & 0xFFFF);
    ptp_ts[4] = htons(ns & 0xFFFF);
}

void init_header(PTPHeader *h, uint8_t type, uint16_t len, uint16_t seq, uint16_t flags) {
    memset(h, 0, sizeof(PTPHeader));
    h->transportSpecific_msgType = type;
    h->versionPTP = PTP_VERSION;
    h->messageLength = htons(len);
    h->domainNumber = 0;
    h->flagField = htons(flags);
    memcpy(h->clockIdentity, my_clock_id, 8);
    h->sourcePortId = htons(1);
    h->sequenceId = htons(seq);
    h->logMessageInterval = 0;
}

int setup_socket(int port, const char *iface_ip) {
    int sock = socket(AF_INET, SOCK_DGRAM, 0);
    if (sock < 0) { perror("socket"); exit(1); }

    int reuse = 1;
    setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, &reuse, sizeof(reuse));

    struct sockaddr_in addr;
    memset(&addr, 0, sizeof(addr));
    addr.sin_family = AF_INET;
    addr.sin_port = htons(port);
    addr.sin_addr.s_addr = htonl(INADDR_ANY);

    if (bind(sock, (struct sockaddr*)&addr, sizeof(addr)) < 0) {
        perror("bind"); exit(1);
    }

    // Multicast Setup
    struct ip_mreq mreq;
    mreq.imr_multiaddr.s_addr = inet_addr(MCAST_ADDR);
    mreq.imr_interface.s_addr = inet_addr(iface_ip);
    if (setsockopt(sock, IPPROTO_IP, IP_ADD_MEMBERSHIP, &mreq, sizeof(mreq)) < 0) {
        perror("add_membership");
        fprintf(stderr, "Hint: Check if route exists for 224.0.0.0/4\n");
    }
    
    // Set outgoing interface
    struct in_addr local_if;
    local_if.s_addr = inet_addr(iface_ip);
    if (setsockopt(sock, IPPROTO_IP, IP_MULTICAST_IF, &local_if, sizeof(local_if)) < 0) {
        perror("set_multicast_if");
    }

    return sock;
}

// --- Master Logic ---

void run_master() {
    printf("Starting PTP Master on %s...\n", interface_ip);
    
    while(1) {
        struct timespec ts;
        get_time(&ts);
        uint16_t seq = sequence_id++;

        // 1. Send Sync (Event Port)
        PTPSync sync;
        init_header(&sync.header, MSG_SYNC, SYNC_LEN, seq, 0x0200); // TwoStep flag
        memset(sync.originTimestamp, 0, sizeof(sync.originTimestamp));
        
        sendto(sock_evt, &sync, sizeof(sync), 0, (struct sockaddr*)&mcast_addr_evt, sizeof(mcast_addr_evt));
        printf("[Master] Sent Sync Seq=%d\n", seq);

        // 2. Send FollowUp (General Port)
        usleep(1000); // 1ms delay
        PTPFollowUp follow;
        init_header(&follow.header, MSG_FOLLOW_UP, FOLLOW_UP_LEN, seq, 0x0000);
        timespec_to_ptp(&ts, follow.preciseOriginTimestamp);
        
        sendto(sock_gen, &follow, sizeof(follow), 0, (struct sockaddr*)&mcast_addr_gen, sizeof(mcast_addr_gen));
        printf("[Master] Sent FollowUp Seq=%d Time=%ld.%09ld\n", seq, ts.tv_sec, ts.tv_nsec);

        // Check for DelayReq (Non-blocking check would be better, but simple select here)
        fd_set fds;
        struct timeval tv = {0, 900000}; // Wait remainder of second
        FD_ZERO(&fds);
        FD_SET(sock_evt, &fds);
        
        if (select(sock_evt + 1, &fds, NULL, NULL, &tv) > 0) {
            uint8_t buf[1024];
            struct sockaddr_in src_addr;
            socklen_t addrlen = sizeof(src_addr);
            int len = recvfrom(sock_evt, buf, sizeof(buf), 0, (struct sockaddr*)&src_addr, &addrlen);
            
            if (len >= HEADER_LEN) {
                PTPHeader *h = (PTPHeader*)buf;
                if ((h->transportSpecific_msgType & 0x0F) == MSG_DELAY_REQ) {
                    struct timespec rx_ts;
                    get_time(&rx_ts);
                    uint16_t req_seq = ntohs(h->sequenceId);
                    printf("[Master] Received DelayReq Seq=%d from %s\n", req_seq, inet_ntoa(src_addr.sin_addr));

                    // Send DelayResp
                    PTPDelayResp resp;
                    init_header(&resp.header, MSG_DELAY_RESP, DELAY_RESP_LEN, req_seq, 0);
                    timespec_to_ptp(&rx_ts, resp.receiveTimestamp);
                    memcpy(resp.requestingPortIdentity, h->clockIdentity, 8);
                    memcpy(resp.requestingPortIdentity + 8, &h->sourcePortId, 2); // Actually portId is 2 bytes

                    // Send unicast back to requester
                    sendto(sock_gen, &resp, sizeof(resp), 0, (struct sockaddr*)&src_addr, addrlen);
                    printf("[Master] Sent DelayResp Seq=%d\n", req_seq);
                }
            }
        }
    }
}

// --- Slave Logic ---

void run_slave() {
    printf("Starting PTP Slave on %s...\n", interface_ip);
    slave_state.last_sync_seq = -1;
    slave_state.has_initial_offset = 0;

    fd_set fds;
    while(1) {
        FD_ZERO(&fds);
        FD_SET(sock_evt, &fds);
        FD_SET(sock_gen, &fds);
        
        // Timeout for sending DelayReq (e.g. every 4s)
        struct timeval tv = {1, 0}; 
        
        int ret = select(sock_gen + 1, &fds, NULL, NULL, &tv);
        
        if (ret > 0) {
            uint8_t buf[1024];
            struct sockaddr_in src_addr;
            socklen_t addrlen = sizeof(src_addr);

            // Check Event Port (Sync, DelayResp if wrong port)
            if (FD_ISSET(sock_evt, &fds)) {
                int len = recvfrom(sock_evt, buf, sizeof(buf), 0, (struct sockaddr*)&src_addr, &addrlen);
                if (len >= HEADER_LEN) {
                    struct timespec rx_ts;
                    get_time(&rx_ts); // Capture Ingress Time
                    
                    PTPHeader *h = (PTPHeader*)buf;
                    uint8_t type = h->transportSpecific_msgType & 0x0F;
                    uint16_t seq = ntohs(h->sequenceId);

                    if (type == MSG_SYNC) {
                        slave_state.t2 = rx_ts;
                        slave_state.last_sync_seq = seq;
                        // printf("[Slave] Rx Sync Seq=%d\n", seq);
                    } else if (type == MSG_DELAY_RESP) {
                         // Handle DelayResp on wrong port
                         PTPDelayResp *resp = (PTPDelayResp*)buf;
                         ptp_to_timespec(resp->receiveTimestamp, &slave_state.t4);
                         
                         // Calculate Delay
                         int64_t t1_ns = (int64_t)slave_state.t1.tv_sec * 1000000000LL + slave_state.t1.tv_nsec;
                         int64_t t2_ns = (int64_t)slave_state.t2.tv_sec * 1000000000LL + slave_state.t2.tv_nsec;
                         int64_t t3_ns = (int64_t)slave_state.t3.tv_sec * 1000000000LL + slave_state.t3.tv_nsec;
                         int64_t t4_ns = (int64_t)slave_state.t4.tv_sec * 1000000000LL + slave_state.t4.tv_nsec;
                         
                         int64_t ms_diff = t2_ns - t1_ns;
                         int64_t sm_diff = t4_ns - t3_ns;
                         double delay_ms = (double)(ms_diff + sm_diff) / 2.0 / 1000000.0;
                         
                         printf("[Slave] Path Delay: %.3f ms\n", delay_ms);
                    }
                }
            }

            // Check General Port (FollowUp, DelayResp)
            if (FD_ISSET(sock_gen, &fds)) {
                int len = recvfrom(sock_gen, buf, sizeof(buf), 0, (struct sockaddr*)&src_addr, &addrlen);
                if (len >= HEADER_LEN) {
                    PTPHeader *h = (PTPHeader*)buf;
                    uint8_t type = h->transportSpecific_msgType & 0x0F;
                    uint16_t seq = ntohs(h->sequenceId);

                    if (type == MSG_FOLLOW_UP) {
                        if (seq == slave_state.last_sync_seq) {
                            PTPFollowUp *fu = (PTPFollowUp*)buf;
                            ptp_to_timespec(fu->preciseOriginTimestamp, &slave_state.t1);
                            
                            int64_t t1_ns = (int64_t)slave_state.t1.tv_sec * 1000000000LL + slave_state.t1.tv_nsec;
                            int64_t t2_ns = (int64_t)slave_state.t2.tv_sec * 1000000000LL + slave_state.t2.tv_nsec;
                            int64_t offset_ns = t2_ns - t1_ns;

                            if (!slave_state.has_initial_offset) {
                                slave_state.initial_offset_ns = offset_ns;
                                slave_state.has_initial_offset = 1;
                            }

                            double drift_ms = (double)(offset_ns - slave_state.initial_offset_ns) / 1000000.0;
                            printf("[Slave] Master Time: %ld.%09ld | Drift: %.3f ms\n", 
                                slave_state.t1.tv_sec, slave_state.t1.tv_nsec, drift_ms);
                                
                            // Send DelayReq occasionally (e.g. every 4th sync)
                            if (seq % 4 == 0) {
                                PTPDelayReq req;
                                init_header(&req.header, MSG_DELAY_REQ, DELAY_REQ_LEN, sequence_id++, 0);
                                memset(req.originTimestamp, 0, sizeof(req.originTimestamp));
                                
                                get_time(&slave_state.t3);
                                sendto(sock_evt, &req, sizeof(req), 0, (struct sockaddr*)&mcast_addr_evt, sizeof(mcast_addr_evt));
                                printf("[Slave] Sent DelayReq Seq=%d\n", ntohs(req.header.sequenceId));
                            }
                        }
                    } else if (type == MSG_DELAY_RESP) {
                         PTPDelayResp *resp = (PTPDelayResp*)buf;
                         ptp_to_timespec(resp->receiveTimestamp, &slave_state.t4);
                         
                         int64_t t1_ns = (int64_t)slave_state.t1.tv_sec * 1000000000LL + slave_state.t1.tv_nsec;
                         int64_t t2_ns = (int64_t)slave_state.t2.tv_sec * 1000000000LL + slave_state.t2.tv_nsec;
                         int64_t t3_ns = (int64_t)slave_state.t3.tv_sec * 1000000000LL + slave_state.t3.tv_nsec;
                         int64_t t4_ns = (int64_t)slave_state.t4.tv_sec * 1000000000LL + slave_state.t4.tv_nsec;
                         
                         int64_t ms_diff = t2_ns - t1_ns;
                         int64_t sm_diff = t4_ns - t3_ns;
                         double delay_ms = (double)(ms_diff + sm_diff) / 2.0 / 1000000.0;
                         
                         printf("[Slave] Path Delay: %.3f ms\n", delay_ms);
                    }
                }
            }
        }
    }
}

int main(int argc, char *argv[]) {
    if (argc < 3) {
        fprintf(stderr, "Usage: %s <interface_ip> <master|slave>\n", argv[0]);
        return 1;
    }

    strncpy(interface_ip, argv[1], INET_ADDRSTRLEN);
    int is_master = (strcmp(argv[2], "master") == 0);

    // Setup Sockets
    sock_evt = setup_socket(PTP_PORT_EVENT, interface_ip);
    sock_gen = setup_socket(PTP_PORT_GENERAL, interface_ip);

    // Setup Dest Addrs
    memset(&mcast_addr_evt, 0, sizeof(mcast_addr_evt));
    mcast_addr_evt.sin_family = AF_INET;
    mcast_addr_evt.sin_port = htons(PTP_PORT_EVENT);
    mcast_addr_evt.sin_addr.s_addr = inet_addr(MCAST_ADDR);

    memset(&mcast_addr_gen, 0, sizeof(mcast_addr_gen));
    mcast_addr_gen.sin_family = AF_INET;
    mcast_addr_gen.sin_port = htons(PTP_PORT_GENERAL);
    mcast_addr_gen.sin_addr.s_addr = inet_addr(MCAST_ADDR);

    if (is_master) {
        run_master();
    } else {
        run_slave();
    }

    return 0;
}
