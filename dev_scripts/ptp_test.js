// this file is ai generated by gemini 3 pro


const dgram = require('dgram');
const os = require('os');

// PTPv2 Constants
const PTP_VERSION = 2;
const PTP_PORT_EVENT = 319;
const PTP_PORT_GENERAL = 320;
const MCAST_ADDR = '224.0.1.129';

// Message Types
const MSG_TYPE_SYNC = 0x0;
const MSG_TYPE_DELAY_REQ = 0x1;
const MSG_TYPE_PDELAY_REQ = 0x2;
const MSG_TYPE_PDELAY_RESP = 0x3;
const MSG_TYPE_FOLLOW_UP = 0x8;
const MSG_TYPE_DELAY_RESP = 0x9;
const MSG_TYPE_PDELAY_RESP_FOLLOW_UP = 0xA;
const MSG_TYPE_ANNOUNCE = 0xB;
const MSG_TYPE_SIGNALING = 0xC;
const MSG_TYPE_MANAGEMENT = 0xD;

// Map for Debugging
const MSG_TYPE_NAMES = {
    0x0: 'Sync',
    0x1: 'Delay_Req',
    0x2: 'PDelay_Req',
    0x3: 'PDelay_Resp',
    0x8: 'Follow_Up',
    0x9: 'Delay_Resp',
    0xA: 'PDelay_Resp_Follow_Up',
    0xB: 'Announce',
    0xC: 'Signaling',
    0xD: 'Management'
};

// Packet Lengths (Basic)
const HEADER_LENGTH = 34;
const SYNC_LENGTH = 44;
const FOLLOW_UP_LENGTH = 44;
const DELAY_REQ_LENGTH = 44;
const DELAY_RESP_LENGTH = 54;

// Configuration
// IMPORTANT: Set this to the IP address of the network interface connected to the FPGA/MCU
// You can find this by running 'ip addr' or 'ifconfig' in your terminal.
const INTERFACE_IP = '10.42.0.1'; 
const SYNC_INTERVAL_MS = 1000; // 1 Sync per second
const DELAY_REQ_INTERVAL_MS = 4000; // Slave: Send Delay_Req every 4s

// Mode Selection
const args = process.argv.slice(2);
const MODE = args[0] === 'slave' ? 'slave' : 'master';
console.log(`[Init] Starting in ${MODE.toUpperCase()} mode...`);

// Verify Interface Exists
const interfaces = os.networkInterfaces();
let ifaceFound = false;
Object.keys(interfaces).forEach(iface => {
    interfaces[iface].forEach(details => {
        if (details.address === INTERFACE_IP) {
            console.log(`[Setup] Found interface '${iface}' with IP ${INTERFACE_IP}`);
            ifaceFound = true;
        }
    });
});

if (!ifaceFound) {
    console.error(`[Error] IP ${INTERFACE_IP} not found on any network interface!`);
    console.log("Available interfaces:", JSON.stringify(interfaces, null, 2));
    process.exit(1);
}

// State
let sequenceId = 0;
const clockIdentity = Buffer.alloc(8);
// Generate a fake ClockIdentity (MAC address + padding)
clockIdentity.writeUInt32BE(0x112233FF, 0);
clockIdentity.writeUInt32BE(0xFE445566, 4);

// Slave State
let slaveState = {
    lastSyncSeq: -1,
    t1: null, // Master Sync Timestamp (from FollowUp)
    t2: null, // Slave Sync Ingress Timestamp
    t3: null, // Slave Delay_Req Egress Timestamp
    t4: null, // Master Delay_Req Ingress Timestamp (from Delay_Resp)
    initialOffset: null
};

// Sockets
const socketEvent = dgram.createSocket({ type: 'udp4', reuseAddr: true });
const socketGeneral = dgram.createSocket({ type: 'udp4', reuseAddr: true });

function createPTPHeader(msgType, length, seqId, control) {
    const buf = Buffer.alloc(HEADER_LENGTH);
    
    // 0: transportSpecific (0) | messageType
    buf.writeUInt8(msgType & 0x0F, 0);
    
    // 1: versionPTP (2)
    buf.writeUInt8(PTP_VERSION & 0x0F, 1);
    
    // 2-3: messageLength
    buf.writeUInt16BE(length, 2);
    
    // 4: domainNumber (0 default)
    buf.writeUInt8(0, 4);
    
    // 5: reserved
    buf.writeUInt8(0, 5);
    
    // 6-7: flagField (TwoStep = bit 1 of byte 6 => 0x0200)
    // We will use Two-Step clock (Sync + FollowUp)
    buf.writeUInt16BE(0x0200, 6);
    
    // 8-15: correctionField (0)
    buf.fill(0, 8, 16);
    
    // 16-19: reserved
    buf.fill(0, 16, 20);
    
    // 20-29: sourcePortIdentity (ClockIdentity + PortNumber)
    clockIdentity.copy(buf, 20);
    buf.writeUInt16BE(1, 28); // Port Number 1
    
    // 30-31: sequenceId
    buf.writeUInt16BE(seqId, 30);
    
    // 32: controlField (Legacy, depends on msg type)
    buf.writeUInt8(control, 32);
    
    // 33: logMessageInterval (0 = 1s)
    buf.writeInt8(0, 33);
    
    return buf;
}

function getTimestamp() {
    const now = new Date();
    const seconds = Math.floor(now.getTime() / 1000);
    const nanoseconds = (now.getTime() % 1000) * 1000000;
    return { seconds, nanoseconds };
}

// --- Master Functions ---

function sendSync() {
    const seq = sequenceId++;
    const ts = getTimestamp();
    
    // --- 1. Send Sync (Event Port 319) ---
    // In Two-Step, the Sync message carries an estimated or zero timestamp
    const syncBuf = Buffer.alloc(SYNC_LENGTH);
    const syncHeader = createPTPHeader(MSG_TYPE_SYNC, SYNC_LENGTH, seq, 0x00);
    syncHeader.copy(syncBuf, 0);
    
    // OriginTimestamp (0 for Two-Step)
    syncBuf.fill(0, 34, 44);
    
    socketEvent.send(syncBuf, PTP_PORT_EVENT, MCAST_ADDR, (err) => {
        if (err) {
            console.error('Error sending Sync:', err);
            if (err.code === 'ENETUNREACH') {
                console.error('\n[!] Network Unreachable. You may need to add a multicast route:');
                console.error(`    sudo ip route add 224.0.0.0/4 dev <YOUR_INTERFACE_NAME>`);
            }
        }
        else console.log(`[Master] Sent Sync Seq=${seq}`);
    });

    // --- 2. Send Follow_Up (General Port 320) ---
    // Carries the precise timestamp
    setTimeout(() => {
        const followUpBuf = Buffer.alloc(FOLLOW_UP_LENGTH);
        const followUpHeader = createPTPHeader(MSG_TYPE_FOLLOW_UP, FOLLOW_UP_LENGTH, seq, 0x02);
        followUpHeader.copy(followUpBuf, 0);
        
        // Precise OriginTimestamp
        // Seconds (48 bits)
        followUpBuf.writeUInt16BE(0, 34); // Upper 16 bits
        followUpBuf.writeUInt32BE(ts.seconds, 36); // Lower 32 bits
        // Nanoseconds (32 bits)
        followUpBuf.writeUInt32BE(ts.nanoseconds, 40);
        
        socketGeneral.send(followUpBuf, PTP_PORT_GENERAL, MCAST_ADDR, (err) => {
            if (err) {
                console.error('Error sending FollowUp:', err);
                if (err.code === 'ENETUNREACH') {
                    console.error('\n[!] Network Unreachable. You may need to add a multicast route:');
                    console.error(`    sudo ip route add 224.0.0.0/4 dev <YOUR_INTERFACE_NAME>`);
                }
            }
            else console.log(`[Master] Sent FollowUp Seq=${seq} Time=${ts.seconds}.${ts.nanoseconds}`);
        });
    }, 10); // Small delay
}

function handleDelayReq(msg, rinfo) {
    // Parse Header
    const seqId = msg.readUInt16BE(30);
    const domain = msg.readUInt8(4);
    const correction = msg.readBigUInt64BE(8); // Requires Node 10+
    const sourcePortIdentity = msg.slice(20, 30);
    
    console.log(`[Master] Received Delay_Req Seq=${seqId} from ${rinfo.address}`);

    // Send Delay_Resp (General Port 320)
    // We simply echo the time we received it (simulated as "now")
    const ts = getTimestamp();
    
    const respBuf = Buffer.alloc(DELAY_RESP_LENGTH);
    const respHeader = createPTPHeader(MSG_TYPE_DELAY_RESP, DELAY_RESP_LENGTH, seqId, 0x03);
    respHeader.copy(respBuf, 0);
    
    // Timestamp (Receive Timestamp of Delay_Req)
    respBuf.writeUInt16BE(0, 34);
    respBuf.writeUInt32BE(ts.seconds, 36);
    respBuf.writeUInt32BE(ts.nanoseconds, 40);
    
    // RequestingPortIdentity (Copy from Delay_Req)
    sourcePortIdentity.copy(respBuf, 44);
    
    socketGeneral.send(respBuf, PTP_PORT_GENERAL, rinfo.address, (err) => { // Unicast response usually
        if (err) console.error('Error sending Delay_Resp:', err);
        else console.log(`[Master] Sent Delay_Resp Seq=${seqId} to ${rinfo.address}`);
    });
}

// --- Slave Functions ---

function sendDelayReq() {
    const seq = sequenceId++;
    const ts = getTimestamp();
    slaveState.t3 = ts; // Record Egress Time

    const reqBuf = Buffer.alloc(DELAY_REQ_LENGTH);
    const reqHeader = createPTPHeader(MSG_TYPE_DELAY_REQ, DELAY_REQ_LENGTH, seq, 0x01);
    reqHeader.copy(reqBuf, 0);
    
    // OriginTimestamp (0)
    reqBuf.fill(0, 34, 44);

    socketEvent.send(reqBuf, PTP_PORT_EVENT, MCAST_ADDR, (err) => {
        if (err) console.error('Error sending Delay_Req:', err);
        else console.log(`[Slave] Sent Delay_Req Seq=${seq}`);
    });
}

function handleSync(msg, rinfo) {
    const seqId = msg.readUInt16BE(30);
    slaveState.lastSyncSeq = seqId;
    slaveState.t2 = getTimestamp(); // Record Ingress Time
    console.log(`[Slave] Received Sync Seq=${seqId}`);
}

function handleFollowUp(msg, rinfo) {
    const seqId = msg.readUInt16BE(30);
    if (seqId !== slaveState.lastSyncSeq) {
        console.warn(`[Slave] FollowUp Seq=${seqId} does not match last Sync Seq=${slaveState.lastSyncSeq}`);
        return;
    }

    // Extract Precise Origin Timestamp (t1)
    const seconds = msg.readUInt32BE(36); // Assuming upper 16 bits are 0 for simplicity
    const nanoseconds = msg.readUInt32BE(40);
    slaveState.t1 = { seconds, nanoseconds };

    // Calculate Offset = t2 - t1
    // (Assuming t2 > t1 for simplicity, real PTP handles negative)
    const offsetNs = (slaveState.t2.seconds - slaveState.t1.seconds) * 1e9 + (slaveState.t2.nanoseconds - slaveState.t1.nanoseconds);
    
    if (slaveState.initialOffset === null) {
        slaveState.initialOffset = offsetNs;
    }
    
    const driftNs = offsetNs - slaveState.initialOffset;

    console.log(`[Slave] Master Time: ${slaveState.t1.seconds}.${String(slaveState.t1.nanoseconds).padStart(9, '0')}s`);
    console.log(`[Slave] Offset: ${(offsetNs / 1e6).toFixed(3)} ms | Drift: ${(driftNs / 1e6).toFixed(3)} ms`);
}

function handleDelayResp(msg, rinfo) {
    const seqId = msg.readUInt16BE(30);
    console.log(`[Slave] Received Delay_Resp Seq=${seqId}`);
    
    // Extract Receive Timestamp (t4)
    const seconds = msg.readUInt32BE(36);
    const nanoseconds = msg.readUInt32BE(40);
    slaveState.t4 = { seconds, nanoseconds };

    if (slaveState.t3 && slaveState.t1 && slaveState.t2) {
        // Calculate Mean Path Delay
        // Formula: [(t2 - t1) + (t4 - t3)] / 2
        
        // Use BigInt to avoid precision loss with large epoch differences
        const t1Ns = BigInt(slaveState.t1.seconds) * 1_000_000_000n + BigInt(slaveState.t1.nanoseconds);
        const t2Ns = BigInt(slaveState.t2.seconds) * 1_000_000_000n + BigInt(slaveState.t2.nanoseconds);
        const t3Ns = BigInt(slaveState.t3.seconds) * 1_000_000_000n + BigInt(slaveState.t3.nanoseconds);
        const t4Ns = BigInt(slaveState.t4.seconds) * 1_000_000_000n + BigInt(slaveState.t4.nanoseconds);

        const masterToSlaveDiff = t2Ns - t1Ns; // Huge positive (Offset + Delay)
        const slaveToMasterDiff = t4Ns - t3Ns; // Huge negative (-Offset + Delay)
        
        const meanPathDelayNs = Number(masterToSlaveDiff + slaveToMasterDiff) / 2;
        
        console.log(`[Slave] Path Delay: ${(meanPathDelayNs / 1e6).toFixed(3)} ms`);
    }
}

// --- Setup Sockets ---

socketEvent.bind(PTP_PORT_EVENT, '0.0.0.0', () => {
    try {
        socketEvent.addMembership(MCAST_ADDR, INTERFACE_IP);
        socketEvent.setMulticastInterface(INTERFACE_IP);
        console.log(`Listening on Event Port ${PTP_PORT_EVENT} (bound to 0.0.0.0, multicast via ${INTERFACE_IP})`);
    } catch (e) {
        console.error(`Error configuring Event socket: ${e.message}`);
    }
});

socketGeneral.bind(PTP_PORT_GENERAL, '0.0.0.0', () => {
    try {
        socketGeneral.addMembership(MCAST_ADDR, INTERFACE_IP);
        socketGeneral.setMulticastInterface(INTERFACE_IP);
        console.log(`Listening on General Port ${PTP_PORT_GENERAL} (bound to 0.0.0.0, multicast via ${INTERFACE_IP})`);
    } catch (e) {
        console.error(`Error configuring General socket: ${e.message}`);
    }
});

socketEvent.on('message', (msg, rinfo) => {
    const msgType = msg.readUInt8(0) & 0x0F;
    
    if (MODE === 'master') {
        if (msgType === MSG_TYPE_DELAY_REQ) {
            handleDelayReq(msg, rinfo);
        }
    } else { // Slave
        if (msgType === MSG_TYPE_SYNC) {
            handleSync(msg, rinfo);
        } else if (msgType === MSG_TYPE_DELAY_RESP) {
            // Handle Delay_Resp if it arrives on Port 319 (Non-standard but possible)
            console.log(`[Slave] Received Delay_Resp on Event Port (319) from ${rinfo.address}`);
            handleDelayResp(msg, rinfo);
        } else {
            const typeName = MSG_TYPE_NAMES[msgType] || 'Unknown';
            // Ignore our own Delay_Req loopback
            if (msgType === MSG_TYPE_DELAY_REQ && rinfo.address === INTERFACE_IP) return;
            
            console.log(`[Slave] Event Port (319) Rx: Type=${msgType} (${typeName}) from ${rinfo.address}`);
        }
    }
});

socketGeneral.on('message', (msg, rinfo) => {
    const msgType = msg.readUInt8(0) & 0x0F;
    
    if (MODE === 'slave') {
        if (msgType === MSG_TYPE_FOLLOW_UP) {
            handleFollowUp(msg, rinfo);
        } else if (msgType === MSG_TYPE_DELAY_RESP) {
            handleDelayResp(msg, rinfo);
        } else {
             const typeName = MSG_TYPE_NAMES[msgType] || 'Unknown';
             // Only log if it's NOT Announce (too spammy)
             if (msgType !== MSG_TYPE_ANNOUNCE) {
                 console.log(`[Slave] General Port (320) Rx: Type=${msgType} (${typeName}) from ${rinfo.address}`);
             }
        }
    }
});

// Start Loop
if (MODE === 'master') {
    console.log("Starting PTPv2 Master...");
    setInterval(sendSync, SYNC_INTERVAL_MS);
} else {
    console.log("Starting PTPv2 Slave...");
    setInterval(sendDelayReq, DELAY_REQ_INTERVAL_MS);
}
